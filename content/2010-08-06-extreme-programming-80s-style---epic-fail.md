layout: post
title: Extreme programming 80s style - epic fail
author: devcurmudgeon
date: 2010/08/06

My first brush with programming was on the [Sinclair Cambridge Programmable Calculator](http://www.rskey.org/detail.asp?manufacturer=Sinclair&model=Cambridge+Programmable). A mathematics teacher got me hooked - if I remember well he was later knocked down and killed by a milk float.

Later I messed about on the [ZX80](http://en.wikipedia.org/wiki/ZX80), [ZX81](http://en.wikipedia.org/wiki/ZX81), [ZX Spectrum](http://en.wikipedia.org/wiki/Sinclair_ZX_Spectrum), and [Sinclair QL](http://en.wikipedia.org/wiki/Sinclair_QL) while sailing gracelessly through school. I never did thank my teachers properly.... too late now, I guess, but thank you very much.

And I wrestled with the [Dragon](http://en.wikipedia.org/wiki/Dragon_32/64) - my first experience of "pair programming"... me and Steve Sharpe trying to re-write the Star Trek game - we missed by a mile... sadly Steve died a few years later - he'd have been a mad professor by now.

So by this time I'd had first-hand exposure to the realities of professional software development, ie

- coding all night
- delivery failure
- getting published (i wrote a game for the Spectrum)
- copyright theft (some turd fan copied my game and got it republished),  
- getting paid (3D space invader game for the QL - Â£500. Not bad for two weeks' work)

I wanted to make things - so I did real Engineering Degree at a real University - only to discover that "Software Engineering" was on the syllabus. Ha!

Having already done some actual coding it was pretty funny to hear lecturers talk about programming in [Z](http://foldoc.org/Z) and [Occam](http://en.wikipedia.org/wiki/Occam_programming_language) like they were going to change the world. This was obviously <strike>bullshit</strike> rocket science, not engineering - concepts too hard for the <strike>lecturers</strike> students to grasp.

Z was great in theory - a way to specify programs <strike>in an incomprehensible format</strike> mathematically. Only trouble was, and is, that <b>in the real world</b> the people who need to specify software don't have a snowball's chance of understanding Z (or finite state machines, or polymorphism, <strike>or Scrum</strike> but I'm getting ahead of myself...)

I've been hitting this same problem from various angles ever since. As a programmer, designer, consultant, project manager, troubleshooter, director, <strike>alcoholic</strike>.... so that's thirty years, on and off... and still I'm struggling to get clear what it takes to make software reliably and efficiently.

Note I'm talking about tough software - o/s level stuff, comms, device drivers, real-time apps, big systems. <strike>Not your grandma's web site or an iPhone fart app.</strike>